# Планы сквозного тестирования (End-to-End Testing) для платформы \"my-platform\"\n\n## 1. Что такое сквозное тестирование (E2E)?\n\nСквозное тестирование проверяет **весь стек приложения** от начала до конца, имитируя реальные сценарии использования продукта с точки зрения пользователя. Цель — убедиться, что все компоненты системы (фронтенд, Django бэкенд, Node.js воркеры, база данных, Redis, Celery) корректно взаимодействуют друг с другом и что информационные потоки проходят через них без ошибок.\n\n## 2. Ключевые сценарии для тестирования\n\nПримеры полных циклов операций, подлежащих тестированию:\n\n1.  **Регистрация и Аутентификация:**\n    *   Регистрация нового пользователя.\n    *   Подтверждение email (если реализовано).\n    *   Вход в систему.\n    *   Настройка и использование 2FA.\n2.  **Пополнение счета (через TemporaryWallet):\**\n    *   Пользователь запрашивает временный кошелек (Фронтенд -> Django).\n    *   Django обращается к Node.js API для генерации кошелька.\n    *   Node.js генерирует кошелек, шифрует ключ, возвращает адрес Django.\n    *   Django сохраняет данные, отображает адрес пользователю (через Фронтенд).\n    *   Симуляция депозита средств на временный адрес.\n    *   Node.js воркер (deposit_monitor) обнаруживает депозит.\n    *   Node.js уведомляет Django о депозите (`/temporary-wallet/notify-deposit/`).\n    *   Django обновляет статус временного кошелька.\n    *   Node.js воркер запрашивает зашифрованный ключ у Django (`/temporary-wallet/<id>/key/`).\n    *   Node.js воркер выполняет свип (включая пополнение на газ, если это EVM ERC20).\n    *   Node.js уведомляет Django о статусе свипа (`/temporary-wallet/notify-sweep/`).\n    *   Django обновляет статус временного кошелька и зачисляет средства на основной баланс пользователя (`InvestmentAccount.balance`).\n    *   Фронтенд отображает обновленный баланс.\n3.  **Инвестиционный цикл (на примере `@cross_arbitrage`):\**\n    *   Пользователь активирует инвестиционный счет, указывая `target_wallet` и `target_wallet_network` (Фронтенд -> Django `/activate/`).\n    *   Celery задача в Django (`generate_daily_payouts_cross_arbitrage`) генерирует ежедневные выплаты для активных и не заблокированных счетов.\n    *   Задача отправляет сообщение о необходимости выплаты в Redis (канал `payouts_cross_arbitrage`).\n    *   Node.js воркер (payout_worker) получает сообщение из Redis.\n    *   Node.js воркер выполняет \"отправку\" USDT на `target_wallet` пользователя (взаимодействие с тестнетом блокчейна или моком).\n    *   Node.js воркер уведомляет Django о статусе выплаты (`/payouts/<id>/update/`).\n    *   Фронтенд отображает информацию о выплате в истории.\n4.  **Цикл вывода средств (пользовательский запрос):\**\n    *   Пользователь запрашивает вывод средств, указывая сумму, сеть и кошелек (Фронтенд -> Django `/withdrawals/create/`).\n    *   Django создает запись `WithdrawalRequest` со статусом `pending`.\n    *   Django отправляет сообщение о необходимости вывода в Redis (канал `withdrawals_cross_arbitrage`).\n    *   Node.js воркер (payout_worker) получает сообщение из Redis.\n    *   Node.js воркер выполняет \"отправку\" USDT на указанный кошелек (взаимодействие с тестнетом блокчейна или моком).\n    *   Node.js воркер уведомляет Django о статусе вывода (`/withdrawals/<id>/update/`).\n    *   Django обновляет статус `WithdrawalRequest`, списывает средства с `InvestmentAccount.balance` в случае успеха.\n    *   Фронтенд отображает обновленный баланс и историю выводов.\n5.  **Просмотр информации:**\n    *   История депозитов (`InvestmentDeposit`).\n    *   История начислений (`DailyPayout`).\n    *   История запросов на вывод (`WithdrawalRequest`).\n    *   Статус инвестиционного счета (`InvestmentAccount`).\n    *   Список активных временных кошельков пользователя.\n\n## 3. Что нужно проверять в каждом сценарии\n\n*   **Корректность прохождения пользовательских сценариев (User Journeys).**\n*   **Взаимодействие компонентов:**\n    *   Фронтенд <-> Django API.\n    *   Django <-> Node.js API (для генерации кошельков).\n    *   Django <-> Redis <-> Node.js воркеры (асинхронные задачи).\n    *   Node.js воркеры <-> Интерфейсы блокчейнов (тестнеты или моки).\n    *   Django <-> Celery (планировщик и выполнение фоновых задач).\n    *   Django <-> База данных PostgreSQL.\n*   **Целостность данных:** Корректность балансов, статусов (временных кошельков, выплат, выводов), пользовательских данных после всех операций.\n*   **Обработка ошибок и граничные случаи:**\n    *   Неверные вводы пользователя (валидация на фронтенде и бэкенде).\n    *   Ошибки сети (симуляция) между сервисами.\n    *   Ошибки транзакций в блокчейне (симуляция, например, отказ транзакции, нехватка газа).\n    *   Недостаток средств для операций.\n    *   Истекшие временные кошельки.\n    *   Попытки операций при заблокированном/неактивном счете.\n    *   Одновременные операции от одного пользователя (если применимо).\n\n## 4. Подход к сквозному тестированию\n\n### 4.1. Подготовка тестового окружения\n\n*   **Полностью развернутое окружение:** Все сервисы (Django, Node.js API, Node.js воркеры, Redis, Celery Beat, Celery Worker, PostgreSQL) должны быть запущены и корректно сконфигурированы для совместной работы (переменные окружения, сетевые настройки).\n*   **Тестовые сети блокчейнов:** Использовать тестовые сети (например, Tron Shasta, BSC Testnet, Arbitrum Goerli/Sepolia) для операций, включающих реальные (но бесплатные) транзакции. Это позволит проверить взаимодействие с реальными нодами.\n*   **Моки (заглушки):** Если работа с тестнетами затруднительна для частых тестов, разработать моки для блокчейн-сервисов в `node-wallet` (`evmService.js`, `tron.js`). Моки должны имитировать успешные/неуспешные транзакции и возвращать ожидаемые данные.\n*   **Начальные данные (Seed Data):** Подготовить скрипты или фикстуры для создания тестовых пользователей, конфигураций (`InvestmentConfig`) и других необходимых начальных данных.\n\n### 4.2. Ручное сквозное тестирование\n\n*   **Обязательный первый шаг.** Пройти все ключевые пользовательские сценарии вручную.\n*   Использовать инструменты разработчика в браузере для отслеживания запросов/ответов.\n*   Анализировать логи всех сервисов (Django, Node.js, Celery).\n*   Проверять записи в базе данных PostgreSQL (например, через pgAdmin или DBeaver).\n*   Проверять сообщения в Redis (например, через `redis-cli monitor`).\n\n### 4.3. Автоматизированное сквозное тестирование\n\n*   **Цель:** Создать набор тестов, которые можно запускать автоматически для проверки регрессий.\n*   **Типы автоматизации:**\n    *   **UI-автоматизация (Фронтенд):**\n        *   Инструменты: Selenium, Cypress, Playwright.\n        *   Сценарии: Автоматизируют действия пользователя в браузере.\n        *   Плюсы: Максимально приближены к реальному использованию.\n        *   Минусы: Медленные и хрупкие (чувствительны к изменениям в UI).\n    *   **API-уровневое E2E тестирование:**\n        *   Инструменты: Postman (с Newman для CLI), `requests` (Python) + `pytest`, RestAssured (Java).\n        *   Сценарии: Выполняют последовательные вызовы API, имитируя пользовательский путь, без UI. Проверяют взаимодействие между Django и Node.js сервисами, включая асинхронные потоки через Redis.\n        *   Плюсы: Быстрее и стабильнее UI-тестов. Хорошо подходят для проверки логики бэкенда и интеграций.\n\n## 5. Приоритетные сценарии для автоматизации\n\nНачать с \"счастливых путей\" (Happy Paths) для самых критичных функций:\n\n1.  Полный цикл депозита и свипа средств через `TemporaryWallet`.\n2.  Полный цикл активации инвестиции и получения одной автоматической выплаты (для `@cross_arbitrage` или аналогичной стратегии).\n3.  Полный цикл запроса и обработки вывода средств пользователем.\n4.  Регистрация нового пользователя и успешный вход.\n\n## 6. Инструменты и техники\n\n*   **Docker и Docker Compose:** Для создания и управления консистентным тестовым окружением.\n*   **Мокирование и Стабы:** Для изоляции тестируемых компонентов и имитации внешних зависимостей.\n*   **Управление тестовыми данными:** Скрипты для создания (seeding) и очистки (teardown) тестовых данных в БД перед и после каждого тестового прогона.\n*   **CI/CD:** Интеграция автоматизированных E2E тестов в конвейер непрерывной интеграции/доставки (например, GitLab CI, GitHub Actions, Jenkins).\n\n## 7. Проблемы и как с ними бороться\n\n*   **Сложность:** E2E тесты требуют времени на разработку и поддержку. Начинать с малого, с наиболее критичных сценариев.\n*   **Нестабильность (\"Flakiness\"):** Тесты могут падать из-за асинхронности, проблем с таймингами, сетевых задержек. Требует тщательной отладки, использования \"умных\" ожиданий, повторных запусков.\n*   **Время выполнения:** Полный набор E2E тестов может быть долгим. Рассмотреть распараллеливание тестов или запуск только части набора (smoke tests) на каждом коммите, а полного набора — реже (например, ночью).\n\n## 8. С чего начать\n\n1.  **Определить и задокументировать ключевые пользовательские сценарии.**\n2.  **Провести несколько циклов ручного тестирования** по этим сценариям.\n3.  **Настроить полноценное тестовое окружение** с использованием Docker Compose.\n4.  **Выбрать инструменты для автоматизации** (например, `pytest` с `requests` для API-тестов, Playwright/Cypress для UI-тестов).\n5.  **Начать автоматизировать \"счастливые пути\"** для 2-3 самых важных функций.\n6.  **Итерировать:** Постепенно расширять тестовое покрытие, добавлять проверки на негативные сценарии и граничные случаи.\n 